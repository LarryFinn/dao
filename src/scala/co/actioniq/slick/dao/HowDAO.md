# HOW TO DAO #
## Preface ##
You want to write a DAO?  First, you need a table to interact with.  Don't have one?  Here are two simple examples.  
**Table with UUID**
```mysql-sql
CREATE TABLE `lookalikes` (
  `auto_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `id` binary(16) NOT NULL,
  `customer_id` bigint(20) NOT NULL,
  `target_segment_id` bigint(20) NOT NULL,
  `source_segment_id` bigint(20) NOT NULL,
  `created_on` timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `thrift` longtext COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`auto_id`),
  UNIQUE KEY `uq_lookalikes_uuid` (`id`),
  KEY `lookalikes_index` (`customer_id`,`target_segment_id`,`source_segment_id`,`created_on`),
  CONSTRAINT `fk_lookalikes_customer` FOREIGN KEY (`customer_id`) REFERENCES `customer` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB
```
The auto_id is a stupid mysql optimization (it expects rows to be incrementing).  id is a binary(16), which is how you
store uuids.  Customer_id is a filter on this table and part of a key.

**Table with Long id**
```mysql-sql
CREATE TABLE `persisted_segment_definition` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `thrift` longtext COLLATE utf8mb4_unicode_ci,
  `customer_id` bigint(20) NOT NULL,
  `team_id` varchar(36) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `customer$id` (`customer$id`),
  CONSTRAINT `persisted_segment_definition_ibfk_1` FOREIGN KEY (`customer$id`) REFERENCES `customer` (`id`) ON DELETE CASCADE ON UPDATE NO ACTION
) ENGINE=InnoDB
```

## Base Code ##

Now that you have a table, you need to create your DAO and probably service too.  You have two options:
* Copy pasta
* Use super cool generator.

To use the generator, run: `./aiq generate service`  
For help with parameters, run: `./aiq help generate service`

## Implement your logic ##
### Table ###
In the table implementation, add whatever extra fields you care about in the table.  For example:  
`def sourceSegmentId: slick.lifted.Rep[Long] = column[Long]("source_segment_id")`    
If you have any thrift fields that you persist, you should use that type in the field definition.  For example:
`def thrift: slick.lifted.Rep[ExecutionState] = column[ExecutionState]("thrift")`  
You have to tell slick how to convert thrift to a string and back, which is easy.  Just define some implicit val like
`protected implicit val dbMetadataType = ThriftSlick.columnType(driver, ExecutionState)`  
For each field you add, you need to add it to the function that maps to the case class.  For example:
```scala
override def * = ( // scalastyle:ignore
    id,
    teamId,
    customerId,
    sourceSegmentId
  ) <> (YourModel.tupled, YourModel.unapply)
```
### Model ###
For every field you added to the table, add it to the model case class.  For example:
```scala
case class YourModel(
  override val id: DbUUID,
  override val customerId: Long,
  sourceSegmentId: Long
) extends UUIDCustomerModel {
  
}
```
Models need to implement a daoModelWrites function. This function converts your model to JSON.  This is used for 
transaction logging. The generator generates a common one like 
`override def daoModelWrites: Writes[YourModel] = Json.writes[YourModel]`.  You can generate JSON however you want 
(maybe some fields should be shaded).  `Json.writes` is fairly magical and will work for most common field types on
your case class.  For any uncommon types, you need to define a writer for that too.  
**If you are persisting thrift, you will need a json converter for thrift**. If you just have one thrift field, you
can tack the `ThriftWriter[ThriftObjectHere]` trait to your model.  If you have multiple thrift fields, you will need
to define the write implementations manually.  Luckily, this is pretty easy.  For each thrift field you need:
```scala
  implicit val thriftFieldNameWriter = new Writes[T] {
    override def writes(o: T) = ThriftUtils.thriftToSimpleJson(o)
  }
```
Where you have unique names for each thrift field.

### DAO ###
There are a few functions / vals you must implement for your DAO to work.
1. **slickQuery**.  This is the underlying slick table query, the code gets generated by the generator but it looks like
`override protected val slickQuery: TableQuery[YourTable] = yourtable`
2. **validateCreate**.  This validation function gets called by any create style function that has validation enabled
and no validator function is provided.  A general stub if you do not care to validate is  
`override def validateCreate(input: YourModel)(implicit ec: ExecutionContext):
     DBIOAction[FormValidatorMessageSeq, NoStream, Effect.Read] = DBIO.successful(FormValidatorMessageSeq())`
3. **validateUpdate**.  This validation function gets called by any update style function that has validation enabled
and no validator function is provided.  A general stub if you do not care to validate is  
`override def validateUpdate(input: YourModel, original: YourModel)(implicit ec: ExecutionContext):
   DBIOAction[FormValidatorMessageSeq, NoStream, Effect.Read] = DBIO.successful(FormValidatorMessageSeq())`
4. **nameSingle**.  How to refer to your model in built in error messages (like trying to update an invalid object)

And now you have a bunch of wonderful and awesome functions to use externally via your DAO.  